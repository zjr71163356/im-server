// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: message_index.sql

package dao

import (
	"context"
	"database/sql"
)

const getConversationMessages = `-- name: GetConversationMessages :many
SELECT message_id, conversation_id, sender_id, recipient_id, message_type, seq, reply_to_msg_id, status, created_at, updated_at FROM message_index
WHERE conversation_id = ?
ORDER BY seq DESC
LIMIT ? OFFSET ?
`

type GetConversationMessagesParams struct {
	ConversationID string `json:"conversation_id"`
	Limit          int32  `json:"limit"`
	Offset         int32  `json:"offset"`
}

func (q *Queries) GetConversationMessages(ctx context.Context, arg GetConversationMessagesParams) ([]MessageIndex, error) {
	rows, err := q.db.QueryContext(ctx, getConversationMessages, arg.ConversationID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MessageIndex{}
	for rows.Next() {
		var i MessageIndex
		if err := rows.Scan(
			&i.MessageID,
			&i.ConversationID,
			&i.SenderID,
			&i.RecipientID,
			&i.MessageType,
			&i.Seq,
			&i.ReplyToMsgID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnreadByUserAndConversation = `-- name: GetUnreadByUserAndConversation :one
SELECT unread_count FROM user_conversation
WHERE user_id = ? AND conversation_id = ?
`

type GetUnreadByUserAndConversationParams struct {
	UserID         uint64 `json:"user_id"`
	ConversationID string `json:"conversation_id"`
}

func (q *Queries) GetUnreadByUserAndConversation(ctx context.Context, arg GetUnreadByUserAndConversationParams) (sql.NullInt32, error) {
	row := q.db.QueryRowContext(ctx, getUnreadByUserAndConversation, arg.UserID, arg.ConversationID)
	var unread_count sql.NullInt32
	err := row.Scan(&unread_count)
	return unread_count, err
}

const incrUnreadOnRecipient = `-- name: IncrUnreadOnRecipient :exec
UPDATE user_conversation
SET unread_count = unread_count + 1, updated_at = CURRENT_TIMESTAMP
WHERE user_id = ? AND conversation_id = ?
`

type IncrUnreadOnRecipientParams struct {
	UserID         uint64 `json:"user_id"`
	ConversationID string `json:"conversation_id"`
}

func (q *Queries) IncrUnreadOnRecipient(ctx context.Context, arg IncrUnreadOnRecipientParams) error {
	_, err := q.db.ExecContext(ctx, incrUnreadOnRecipient, arg.UserID, arg.ConversationID)
	return err
}

const insertMessageIndex = `-- name: InsertMessageIndex :exec
INSERT INTO message_index (
  message_id, conversation_id, sender_id, recipient_id, message_type, seq, reply_to_msg_id, status
) VALUES (
  ?, ?, ?, ?, ?, ?, ?, ?
)
`

type InsertMessageIndexParams struct {
	MessageID      string         `json:"message_id"`
	ConversationID string         `json:"conversation_id"`
	SenderID       uint64         `json:"sender_id"`
	RecipientID    uint64         `json:"recipient_id"`
	MessageType    int8           `json:"message_type"`
	Seq            int64          `json:"seq"`
	ReplyToMsgID   sql.NullString `json:"reply_to_msg_id"`
	Status         sql.NullInt16  `json:"status"`
}

func (q *Queries) InsertMessageIndex(ctx context.Context, arg InsertMessageIndexParams) error {
	_, err := q.db.ExecContext(ctx, insertMessageIndex,
		arg.MessageID,
		arg.ConversationID,
		arg.SenderID,
		arg.RecipientID,
		arg.MessageType,
		arg.Seq,
		arg.ReplyToMsgID,
		arg.Status,
	)
	return err
}

const markRead = `-- name: MarkRead :exec
UPDATE user_conversation
SET last_read_seq = GREATEST(last_read_seq, ?), unread_count = 0, updated_at = CURRENT_TIMESTAMP
WHERE user_id = ? AND conversation_id = ?
`

type MarkReadParams struct {
	GREATEST       interface{} `json:"GREATEST"`
	UserID         uint64      `json:"user_id"`
	ConversationID string      `json:"conversation_id"`
}

func (q *Queries) MarkRead(ctx context.Context, arg MarkReadParams) error {
	_, err := q.db.ExecContext(ctx, markRead, arg.GREATEST, arg.UserID, arg.ConversationID)
	return err
}

const upsertConversationOnSend = `-- name: UpsertConversationOnSend :exec
INSERT INTO conversation (conversation_id, type, participants, last_message_id, last_seq)
VALUES (?, 1, JSON_ARRAY(?, ?), ?, ?)
ON DUPLICATE KEY UPDATE last_message_id = VALUES(last_message_id), last_seq = VALUES(last_seq), updated_at = CURRENT_TIMESTAMP
`

type UpsertConversationOnSendParams struct {
	ConversationID string         `json:"conversation_id"`
	JSONARRAY      interface{}    `json:"JSON_ARRAY"`
	JSONARRAY_2    interface{}    `json:"JSON_ARRAY_2"`
	LastMessageID  sql.NullString `json:"last_message_id"`
	LastSeq        sql.NullInt64  `json:"last_seq"`
}

func (q *Queries) UpsertConversationOnSend(ctx context.Context, arg UpsertConversationOnSendParams) error {
	_, err := q.db.ExecContext(ctx, upsertConversationOnSend,
		arg.ConversationID,
		arg.JSONARRAY,
		arg.JSONARRAY_2,
		arg.LastMessageID,
		arg.LastSeq,
	)
	return err
}

const upsertUserConversationOnSend = `-- name: UpsertUserConversationOnSend :exec
INSERT INTO user_conversation (user_id, conversation_id, last_read_seq, unread_count, is_muted, is_pinned)
VALUES (?, ?, 0, 0, 0, 0)
ON DUPLICATE KEY UPDATE updated_at = CURRENT_TIMESTAMP
`

type UpsertUserConversationOnSendParams struct {
	UserID         uint64 `json:"user_id"`
	ConversationID string `json:"conversation_id"`
}

func (q *Queries) UpsertUserConversationOnSend(ctx context.Context, arg UpsertUserConversationOnSendParams) error {
	_, err := q.db.ExecContext(ctx, upsertUserConversationOnSend, arg.UserID, arg.ConversationID)
	return err
}
