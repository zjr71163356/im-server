### 最新数据库变更 (2025-09-07)

#### 1. 好友申请表 (friend_request) - 新增

```sql
CREATE TABLE `friend_request` (
  `id` bigint unsigned NOT NULL AUTO_INCREMENT COMMENT '自增主键',
  `requester_id` bigint unsigned NOT NULL COMMENT '申请人用户ID',
  `recipient_id` bigint unsigned NOT NULL COMMENT '接收人用户ID',
  `status` tinyint NOT NULL DEFAULT '0' COMMENT '状态：0-待处理，1-已同意，2-已拒绝，3-已忽略',
  `message` varchar(255) NOT NULL DEFAULT '' COMMENT '验证消息',
  `created_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `updated_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  PRIMARY KEY (`id`),
  KEY `idx_recipient_status` (`recipient_id`, `status`) COMMENT '查询待处理申请',
  KEY `idx_requester_recipient` (`requester_id`, `recipient_id`) COMMENT '防重复申请查询',
  KEY `idx_created_at` (`created_at`) COMMENT '按时间排序'
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='好友申请表';
```

#### 2. 好友关系表 (friend) - 重构

原有的 `friend` 表结构优化为独立的好友关系表，与好友申请表分离：

```sql
CREATE TABLE `friend` (
  `id` bigint unsigned NOT NULL AUTO_INCREMENT COMMENT '自增主键',
  `user_id` bigint unsigned NOT NULL COMMENT '用户ID',
  `friend_id` bigint unsigned NOT NULL COMMENT '好友用户ID',
  `remark` varchar(50) NOT NULL DEFAULT '' COMMENT '好友备注',
  `category_id` bigint unsigned NOT NULL DEFAULT '0' COMMENT '好友分类ID，0为默认分组',
  `is_blocked` tinyint NOT NULL DEFAULT '0' COMMENT '是否屏蔽：0-否，1-是',
  `created_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '添加时间',
  `updated_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_user_friend` (`user_id`, `friend_id`) COMMENT '防止重复好友关系',
  KEY `idx_user_id` (`user_id`) COMMENT '查询用户好友列表',
  KEY `idx_friend_id` (`friend_id`) COMMENT '反向查询',
  KEY `idx_category` (`category_id`) COMMENT '按分类查询好友'
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='好友关系表';
```

#### 3. 新增 SQL 查询功能

- **friend_request.sql**: 好友申请的 CRUD 操作
- **friend.sql**: 更新后的好友关系操作，支持分类管理和屏蔽功能

#### 4. 生成的 Go 代码

- `pkg/dao/friend_request.sql.go` - 好友申请表的 SQLC 生成代码
- `pkg/dao/models.go` - 更新了 Friend 和 FriendRequest 结构体
- `pkg/mocks/mock_querier.go` - 更新了 mock 代码

#### 5. 主要改进

1. **分离关注点**: 好友申请和好友关系现在是独立的表
2. **状态管理**: 好友申请有明确的状态流转（待处理 → 已同意/已拒绝/已忽略）
3. **功能增强**: 支持好友分类、备注、屏蔽等功能
4. **索引优化**: 针对常见查询场景添加了合适的索引
5. **数据一致性**: 使用唯一键防止重复好友关系

---

### 最新数据库变更 (2025-09-19)-mysql/mongdb

### SQL 查询方法说明（sqlc 生成）

本节说明 db/queries 中用于消息链路的关键方法，便于在服务中正确调用（通常放入同一 MySQL 事务中执行）。

### InsertMessageIndex

- 作用：在 MySQL 的 `message_index` 表写入一条消息索引（热数据）。
- 参数（按顺序）：
  - message_id, conversation_id, sender_id, recipient_id,
  - message_type, seq, reply_to_msg_id, status
- 何时调用：分配好会话内序列号（seq）后，写索引；消息体写入 MongoDB。
- 典型用法：与 `UpsertConversationOnSend`、`InsertOutboxEvent` 放入同一事务，确保“落库 + 事件”一致。

### UpsertConversationOnSend

- 作用：创建或更新会话元信息（单聊），维护 `last_message_id` 与 `last_seq`。
- 参数（按顺序）：
  - conversation_id, type 固定为 1（单聊，语句内置）, participants=JSON_ARRAY(userA,userB), last_message_id, last_seq
- 何时调用：发送消息时，确保会话存在；若已存在则更新最后一条消息与最新序列号。
- 幂等性：相同 `conversation_id` 多次调用不会重复创建，会更新元信息与 `updated_at`。

### IncrUnreadOnRecipient

- 作用：给接收方在 `user_conversation` 表中对应会话的 `unread_count` + 1。
- 参数（按顺序）：
  - user_id(=recipient_id), conversation_id
- 何时调用：写入 `message_index` 后，为对端累计未读数（发送者自己通常不累加）。
- 注意：需预先通过 `UpsertUserConversationOnSend` 为双方插入一条用户-会话记录（不存在则创建）。

### InsertOutboxEvent

- 作用：在 `outbox_events` 表追加一条待投递事件（状态 `pending`），用于 Outbox 模式的可靠投递。
- 参数（按顺序）：
  - topic, payload(JSON/字节), status(固定 `pending`), retry_count(默认 0), next_delivery_at(NULL)
- 何时调用：与 `InsertMessageIndex` 同一事务内写入，事务提交后由派发器扫描 `pending` 事件并发布到消息队列（如 NATS）。
- 配套方法：
  - `GetPendingOutboxEvents(limit)` 拉取待投递事件
  - `MarkOutboxEventSent(id)` 标记已发送
  - `MarkOutboxEventFailed(id)` 标记失败并回退 `next_delivery_at`

### 推荐事务顺序（伪代码）

```go
err := withTx(ctx, db, func(q *dao.Queries) error {
    // 1) 索引入库（MySQL 热数据）
    if err := q.InsertMessageIndex(ctx, dao.InsertMessageIndexParams{ /* 填充参数 */ }); err != nil { return err }

    // 2) 会话元信息（创建/更新最后消息与序列）
    if err := q.UpsertConversationOnSend(ctx, dao.UpsertConversationOnSendParams{ /* 填充参数 */ }); err != nil { return err }

    // 3) 确保双方 user_conversation 存在
    _ = q.UpsertUserConversationOnSend(ctx, senderID, convID)
    _ = q.UpsertUserConversationOnSend(ctx, recipientID, convID)

    // 4) 为接收方未读+1
    if err := q.IncrUnreadOnRecipient(ctx, dao.IncrUnreadOnRecipientParams{ /* recipientID, convID */ }); err != nil { return err }

    // 5) 写 Outbox 事件（pending）
    if err := q.InsertOutboxEvent(ctx, dao.InsertOutboxEventParams{ /* topic, payload */ }); err != nil { return err }

    return nil
})
// 6) 事务成功后并行：
//    - MongoDB 写消息体（若未在事务前已写）
//    - Outbox 派发器扫描并发布到 MQ
```

以上方法的配合，确保了消息索引、会话状态与可靠事件投递的一致性；消息体采用 MongoDB 存储，实现冷热数据分离与高效查询。


### 