# IM 服务器最佳实践指南

基于 im-server 项目的架构和技术选型，我为您总结一套完整的 IM 服务端最佳实践。

## 1. 架构设计原则

### 1.1 微服务拆分与边界
```
✅ 正确做法：按领域职责拆分
auth      → 注册/登录/JWT校验
user      → 用户资料/搜索
friend    → 好友关系管理
message   → 消息处理核心
connect   → 长连接管理
gateway   → 统一网关/协议转换
device    → 设备状态管理

❌ 错误做法：按技术层拆分或功能混杂
```

### 1.2 服务通信模式
```go
// 同步调用：核心业务链路
gateway → message → friend (校验好友关系)
gateway → auth (JWT校验)

// 异步事件：解耦非关键路径
message → NATS → connect (消息推送)
message → NATS → audit  (审计日志)
```

## 2. 连接层设计 (Connect Service)

### 2.1 连接生命周期管理
```go
// internal/connect/conn.go
type Conn struct {
    UserID    uint64
    DeviceID  uint64
    Transport Transport // WebSocket/TCP抽象
    Hub       *Hub     // 连接管理器
    lastPing  time.Time
}

// 最佳实践：双向心跳
func (c *Conn) StartHeartbeat() {
    ticker := time.NewTicker(30 * time.Second)
    go func() {
        for range ticker.C {
            if time.Since(c.lastPing) > 3*time.Minute {
                c.Close("heartbeat timeout")
                return
            }
            c.SendPing()
        }
    }()
}
```

### 2.2 连接认证流程
```go
// 1. WebSocket握手后必须先认证
func (c *Conn) HandleSignIn(packet *pb.Packet) error {
    var req pb.SignInRequest
    if err := proto.Unmarshal(packet.Data, &req); err != nil {
        return err
    }
    
    // 2. 校验JWT Token
    claims, err := jwt.ValidateToken(req.Token)
    if err != nil {
        return status.Error(codes.Unauthenticated, "invalid token")
    }
    
    // 3. 绑定身份并注册到Hub
    c.UserID = claims.UserID
    c.DeviceID = claims.DeviceID
    c.Hub.Register(c)
    
    return nil
}
```

## 3. 消息处理核心 (Message Service)

### 3.1 消息发送最佳实践
```go
// internal/message/service.go
func (s *MessageService) SendMessage(ctx context.Context, req *pb.SendMessageRequest) (*pb.SendMessageResponse, error) {
    // 1. 参数校验（protoc-gen-validate自动生成）
    if err := req.Validate(); err != nil {
        return nil, status.Error(codes.InvalidArgument, err.Error())
    }
    
    // 2. 幂等性检查
    idempotencyKey := fmt.Sprintf("msg:%d:%d:%s", 
        getUserID(ctx), getDeviceID(ctx), req.ClientMsgId)
    
    if result := s.redis.Get(ctx, idempotencyKey).Val(); result != "" {
        // 返回之前的结果
        return unmarshalPreviousResult(result), nil
    }
    
    // 3. 好友关系校验
    if !s.friendService.AreFriends(ctx, getUserID(ctx), req.RecipientId) {
        return nil, status.Error(codes.PermissionDenied, "not friends")
    }
    
    // 4. 会话管理
    conversationID := s.getOrCreateConversation(ctx, getUserID(ctx), req.RecipientId)
    
    // 5. 分配序列号
    seq := s.redis.Incr(ctx, fmt.Sprintf("conv_seq:%s", conversationID)).Val()
    
    // 6. 数据库事务 + Outbox
    return s.storeMessageWithOutbox(ctx, req, conversationID, seq, idempotencyKey)
}
```

### 3.2 Outbox 模式实现
```go
func (s *MessageService) storeMessageWithOutbox(ctx context.Context, req *pb.SendMessageRequest, conversationID string, seq int64, idempotencyKey string) (*pb.SendMessageResponse, error) {
    tx, err := s.db.BeginTx(ctx, nil)
    if err != nil {
        return nil, err
    }
    defer tx.Rollback()
    
    // 1. 存储消息索引到MySQL
    messageID := s.generateMessageID()
    err = s.queries.WithTx(tx).InsertMessageIndex(ctx, dao.InsertMessageIndexParams{
        MessageID:      messageID,
        ConversationID: conversationID,
        SenderID:       getUserID(ctx),
        RecipientID:    req.RecipientId,
        Seq:            seq,
        CreatedAt:      time.Now(),
    })
    if err != nil {
        return nil, err
    }
    
    // 2. 存储消息体到MongoDB（可异步）
    s.storeMessageBodyAsync(messageID, req.Content)
    
    // 3. 写入Outbox事件
    event := &pb.MessageDeliveryEvent{
        MessageId:      messageID,
        ConversationId: conversationID,
        SenderId:       getUserID(ctx),
        RecipientId:    req.RecipientId,
        Content:        req.Content,
    }
    eventData, _ := proto.Marshal(event)
    
    err = s.queries.WithTx(tx).InsertOutboxEvent(ctx, dao.InsertOutboxEventParams{
        Topic:   "message.deliver",
        Payload: eventData,
        Status:  "pending",
    })
    if err != nil {
        return nil, err
    }
    
    // 4. 提交事务
    if err = tx.Commit(); err != nil {
        return nil, err
    }
    
    // 5. 缓存幂等结果
    result := &pb.SendMessageResponse{
        MessageId:      messageID,
        ConversationId: conversationID,
        Seq:            seq,
        ServerTime:     time.Now().Unix(),
        ClientMsgId:    req.ClientMsgId,
    }
    
    resultData, _ := proto.Marshal(result)
    s.redis.SetEX(ctx, idempotencyKey, resultData, 24*time.Hour)
    
    return result, nil
}
```

## 4. 数据存储最佳实践

### 4.1 冷热数据分离
```sql
-- MySQL: 热数据 - 索引和关系
CREATE TABLE message_index (
    message_id VARCHAR(32) PRIMARY KEY,
    conversation_id VARCHAR(32) NOT NULL,
    sender_id BIGINT NOT NULL,
    recipient_id BIGINT NOT NULL,
    seq BIGINT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_conversation_seq (conversation_id, seq DESC),
    INDEX idx_recipient_time (recipient_id, created_at DESC)
);

CREATE TABLE user_conversation (
    user_id BIGINT NOT NULL,
    conversation_id VARCHAR(32) NOT NULL,
    last_read_seq BIGINT DEFAULT 0,
    unread_count INT DEFAULT 0,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (user_id, conversation_id)
);
```

```javascript
// MongoDB: 冷数据 - 消息体
{
  "_id": "msg_1234567890",
  "conversation_id": "conv_user1_user2",
  "sender_id": 12345,
  "type": "text",
  "content": {
    "text": "Hello world",
    "mentions": [],
    "reply_to": null
  },
  "extra": {
    "client_info": {...}
  },
  "created_at": ISODate("2024-01-01T10:00:00Z")
}
```

### 4.2 序列号管理
```go
// Redis中维护会话序列号
func (s *MessageService) getNextSeq(conversationID string) int64 {
    key := fmt.Sprintf("conv_seq:%s", conversationID)
    return s.redis.Incr(context.Background(), key).Val()
}

// 定期同步到MySQL确保持久化
func (s *MessageService) syncSeqToDB() {
    keys := s.redis.Keys(context.Background(), "conv_seq:*").Val()
    for _, key := range keys {
        conversationID := strings.TrimPrefix(key, "conv_seq:")
        seq := s.redis.Get(context.Background(), key).Val()
        
        s.queries.UpdateConversationSeq(context.Background(), dao.UpdateConversationSeqParams{
            ConversationID: conversationID,
            LastSeq:        parseInt64(seq),
        })
    }
}
```

## 5. 事件驱动架构

### 5.1 Outbox Publisher
```go
// internal/message/outbox.go
type OutboxPublisher struct {
    db     *sql.DB
    nats   *nats.Conn
    logger *zap.Logger
}

func (p *OutboxPublisher) Start() {
    ticker := time.NewTicker(1 * time.Second)
    go func() {
        for range ticker.C {
            p.publishPendingEvents()
        }
    }()
}

func (p *OutboxPublisher) publishPendingEvents() {
    events, err := p.queries.GetPendingOutboxEvents(context.Background(), 100)
    if err != nil {
        p.logger.Error("failed to get pending events", zap.Error(err))
        return
    }
    
    for _, event := range events {
        if err := p.nats.Publish(event.Topic, event.Payload); err != nil {
            p.logger.Error("failed to publish event", zap.Error(err))
            continue
        }
        
        // 标记为已发送
        p.queries.MarkOutboxEventSent(context.Background(), event.ID)
    }
}
```

### 5.2 消息投递服务
```go
// internal/connect/delivery.go
func (d *DeliveryService) Start() {
    // 订阅消息投递事件
    d.nats.Subscribe("message.deliver", d.handleMessageDelivery)
}

func (d *DeliveryService) handleMessageDelivery(msg *nats.Msg) {
    var event pb.MessageDeliveryEvent
    if err := proto.Unmarshal(msg.Data, &event); err != nil {
        return
    }
    
    // 查找接收者的在线连接
    connections := d.hub.GetUserConnections(event.RecipientId)
    
    packet := &pb.Packet{
        Command: pb.Command_NEW_MESSAGE,
        Data:    msg.Data,
    }
    
    for _, conn := range connections {
        conn.Send(packet)
    }
    
    // ACK消息
    msg.Ack()
}
```

## 6. 安全与性能

### 6.1 限流策略
```go
// pkg/middleware/ratelimit.go
func RateLimitMiddleware() grpc.UnaryServerInterceptor {
    // IP级别限流
    ipLimiter := rate.NewLimiter(rate.Every(time.Second), 100)
    
    // 用户级别限流
    userLimiters := sync.Map{}
    
    return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {
        // IP限流检查
        clientIP := getClientIP(ctx)
        if !ipLimiter.Allow() {
            return nil, status.Error(codes.ResourceExhausted, "IP rate limit exceeded")
        }
        
        // 用户限流检查
        if userID := getUserID(ctx); userID > 0 {
            limiter := getUserLimiter(userID, &userLimiters)
            if !limiter.Allow() {
                return nil, status.Error(codes.ResourceExhausted, "user rate limit exceeded")
            }
        }
        
        return handler(ctx, req)
    }
}
```

### 6.2 连接管理优化
```go
// internal/connect/hub.go
type Hub struct {
    // 用户 -> 设备连接映射
    userConnections map[uint64]map[uint64]*Conn
    // 连接池管理
    connPool sync.Pool
    mu       sync.RWMutex
}

func (h *Hub) Register(conn *Conn) {
    h.mu.Lock()
    defer h.mu.Unlock()
    
    if h.userConnections[conn.UserID] == nil {
        h.userConnections[conn.UserID] = make(map[uint64]*Conn)
    }
    
    // 踢掉同设备的旧连接
    if oldConn := h.userConnections[conn.UserID][conn.DeviceID]; oldConn != nil {
        oldConn.Close("new session")
    }
    
    h.userConnections[conn.UserID][conn.DeviceID] = conn
    
    // 更新在线状态到Redis
    h.updateOnlineStatus(conn.UserID, conn.DeviceID, true)
}
```

## 7. 监控与运维

### 7.1 结构化日志
```go
// pkg/logger/logger.go
func NewLogger() *zap.Logger {
    config := zap.NewProductionConfig()
    config.EncoderConfig.TimeKey = "timestamp"
    config.EncoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder
    
    logger, _ := config.Build()
    return logger
}

// 使用示例
logger.Info("message sent",
    zap.String("message_id", messageID),
    zap.Uint64("sender_id", senderID),
    zap.Uint64("recipient_id", recipientID),
    zap.String("conversation_id", conversationID),
    zap.Duration("latency", time.Since(start)),
)
```

### 7.2 健康检查
```go
// internal/auth/health.go
func (s *AuthService) HealthCheck(ctx context.Context, req *pb.HealthCheckRequest) (*pb.HealthCheckResponse, error) {
    // 检查数据库连接
    if err := s.db.PingContext(ctx); err != nil {
        return &pb.HealthCheckResponse{
            Status: pb.HealthCheckResponse_NOT_SERVING,
        }, nil
    }
    
    // 检查Redis连接
    if err := s.redis.Ping(ctx).Err(); err != nil {
        return &pb.HealthCheckResponse{
            Status: pb.HealthCheckResponse_NOT_SERVING,
        }, nil
    }
    
    return &pb.HealthCheckResponse{
        Status: pb.HealthCheckResponse_SERVING,
    }, nil
}
```

## 8. 运维部署

### 8.1 优雅停机
```go
// cmd/auth/main.go
func main() {
    server := grpc.NewServer()
    
    // 注册服务
    pb.RegisterAuthServiceServer(server, authService)
    
    // 启动服务
    go func() {
        if err := server.Serve(listener); err != nil {
            log.Fatal(err)
        }
    }()
    
    // 优雅停机
    sigChan := make(chan os.Signal, 1)
    signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)
    <-sigChan
    
    log.Println("shutting down gracefully...")
    server.GracefulStop()
}
```

### 8.2 配置管理
```go
// pkg/config/config.go
type Config struct {
    Database struct {
        MySQL struct {
            DSN string `yaml:"dsn"`
        } `yaml:"mysql"`
        Redis struct {
            Addr     string `yaml:"addr"`
            Password string `yaml:"password"`
        } `yaml:"redis"`
        MongoDB struct {
            URI      string `yaml:"uri"`
            Database string `yaml:"database"`
        } `yaml:"mongodb"`
    } `yaml:"database"`
    
    Services struct {
        Auth struct {
            RPCAddr string `yaml:"rpc_addr"`
        } `yaml:"auth"`
    } `yaml:"services"`
}
```

## 总结

遵循以上最佳实践，您的 im-server 将具备：

1. **高可扩展性**：微服务架构 + 事件驱动
2. **高可靠性**：Outbox模式 + 幂等设计 + 优雅停机
3. **高性能**：冷热分离 + 连接池 + 限流保护
4. **高可维护性**：清晰的服务边界 + 结构化日志 + 健康检查

这套架构能够支撑从小型团队到大规模商业化的各种场景需求。