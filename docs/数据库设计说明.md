# IM 消息系统数据库设计说明

## 冷热数据分离策略

### MySQL（热数据）- 消息索引与关系

```sql
-- 消息索引表：高频查询的元数据
CREATE TABLE message_index (
    message_id VARCHAR(32) PRIMARY KEY,
    conversation_id VARCHAR(32) NOT NULL,
    sender_id BIGINT NOT NULL,
    recipient_id BIGINT NOT NULL,
    message_type TINYINT NOT NULL,  -- 1:文本 2:图片 3:音频 4:视频 5:文件 6:位置
    seq BIGINT NOT NULL,            -- 会话内序列号
    reply_to_msg_id VARCHAR(32),    -- 回复的消息ID
    status TINYINT DEFAULT 2,       -- 消息状态
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

    INDEX idx_conversation_seq (conversation_id, seq DESC),
    INDEX idx_recipient_time (recipient_id, created_at DESC),
    INDEX idx_sender_time (sender_id, created_at DESC),
    INDEX idx_type_time (message_type, created_at DESC)  -- 按类型查询
);

-- 会话表
CREATE TABLE conversation (
    conversation_id VARCHAR(32) PRIMARY KEY,
    type TINYINT NOT NULL,          -- 1:单聊 2:群聊
    participants JSON NOT NULL,     -- 参与者ID数组
    last_message_id VARCHAR(32),
    last_seq BIGINT DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

    INDEX idx_participants (participants(100))
);

-- 用户会话状态表
CREATE TABLE user_conversation (
    user_id BIGINT NOT NULL,
    conversation_id VARCHAR(32) NOT NULL,
    last_read_seq BIGINT DEFAULT 0,
    unread_count INT DEFAULT 0,
    is_muted BOOLEAN DEFAULT FALSE,
    is_pinned BOOLEAN DEFAULT FALSE,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

    PRIMARY KEY (user_id, conversation_id),
    INDEX idx_user_updated (user_id, updated_at DESC)
);

-- Outbox事件表（确保消息投递一致性）
CREATE TABLE outbox_events (
  id BIGINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
  topic VARCHAR(128) NOT NULL,
  payload JSON NOT NULL,
  status ENUM('pending','sent','failed') NOT NULL DEFAULT 'pending',
  retry_count INT NOT NULL DEFAULT 0,
  next_delivery_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
```

### MongoDB（冷数据）- 完整消息体

```javascript
// messages 集合：存储完整消息内容
{
  "_id": "msg_1234567890",
  "conversation_id": "conv_user1_user2",
  "sender_id": 12345,
  "recipient_id": 67890,
  "message_type": 2,  // 对应 MessageType 枚举
  "content": {
    // 根据消息类型，content 结构不同

    // 文本消息
    "text": "Hello world!",
    "mentions": [
      {"user_id": 67890, "username": "Alice", "offset": 6, "length": 5}
    ]

    // 或图片消息
    // "url": "https://cdn.example.com/images/abc123.jpg",
    // "thumbnail_url": "https://cdn.example.com/thumbs/abc123_thumb.jpg",
    // "width": 1920,
    // "height": 1080,
    // "size": 245760,
    // "format": "jpg",
    // "alt_text": "风景照片"

    // 或音频消息
    // "url": "https://cdn.example.com/audio/voice123.mp3",
    // "duration": 30,
    // "size": 480000,
    // "format": "mp3",
    // "waveform": "data:audio/wav;base64,..."
  },
  "reply_to_msg_id": null,
  "extra": {
    "client_info": {
      "platform": "iOS",
      "version": "1.2.3"
    },
    "is_recalled": false
  },
  "created_at": ISODate("2024-01-01T10:00:00Z")
}

// 索引设计
db.messages.createIndex({"conversation_id": 1, "created_at": -1})
db.messages.createIndex({"message_id": 1})  // 单个消息查询
db.messages.createIndex({"sender_id": 1, "created_at": -1})
db.messages.createIndex({"message_type": 1, "created_at": -1})  // 按类型查询
```

## 为什么要分离不同消息类型？

### 1. 客户端渲染性能

```go
// 不同类型需要不同的UI组件和渲染逻辑
switch msg.Content.(type) {
case *pb.MessageContent_Text:
    return renderTextMessage(msg.GetText())
case *pb.MessageContent_Image:
    return renderImageMessage(msg.GetImage())  // 需要处理缩略图、懒加载
case *pb.MessageContent_Audio:
    return renderAudioMessage(msg.GetAudio())  // 需要播放控件、波形显示
}
```

### 2. 网络传输优化

```go
// 会话列表只需要加载基本信息，大文件延迟加载
func GetConversationList() {
    // 只查询 MySQL 索引表，获取消息类型和基本信息
    messages := queryMessageIndex("SELECT message_id, type, created_at FROM message_index")

    // 对于图片/视频消息，先只显示缩略图
    // 对于音频消息，显示时长但不预加载音频文件
}
```

### 3. 存储和索引优化

```sql
-- 可以为不同类型建立专门的索引
CREATE INDEX idx_image_size ON message_index (message_type, created_at)
WHERE message_type = 2;  -- 只为图片消息建索引

CREATE INDEX idx_audio_duration ON message_index (message_type, created_at)
WHERE message_type = 3;  -- 只为音频消息建索引
```

### 4. 业务逻辑分离

```go
// 不同类型需要不同的校验和处理逻辑
func ValidateMessageContent(content *pb.MessageContent) error {
    switch content.Content.(type) {
    case *pb.MessageContent_Text:
        return validateTextContent(content.GetText())
    case *pb.MessageContent_Image:
        return validateImageContent(content.GetImage())  // 检查图片格式、大小
    case *pb.MessageContent_Audio:
        return validateAudioContent(content.GetAudio())  // 检查音频时长、格式
    }
}

func ProcessMessage(content *pb.MessageContent) {
    switch content.Content.(type) {
    case *pb.MessageContent_Image:
        // 图片需要生成缩略图
        generateThumbnail(content.GetImage())
    case *pb.MessageContent_Audio:
        // 音频可能需要转码
        transcodeAudio(content.GetAudio())
    }
}
```

### 5. 审核和监管

```go
// 不同类型内容需要不同的审核策略
func AuditMessage(content *pb.MessageContent) {
    switch content.Content.(type) {
    case *pb.MessageContent_Text:
        checkSensitiveWords(content.GetText().Text)
    case *pb.MessageContent_Image:
        checkImageContent(content.GetImage().Url)  // 图像识别
    case *pb.MessageContent_Audio:
        checkAudioContent(content.GetAudio().Url)  // 语音识别
    }
}
```

### 6. 统计和分析

```sql
-- 可以方便地按消息类型进行统计分析
SELECT
    message_type,
    COUNT(*) as count,
    DATE(created_at) as date
FROM message_index
WHERE created_at >= '2024-01-01'
GROUP BY message_type, DATE(created_at)
ORDER BY date DESC, message_type;

-- 分析用户偏好的消息类型
SELECT
    sender_id,
    message_type,
    COUNT(*) as usage_count
FROM message_index
GROUP BY sender_id, message_type;
```

## SQL 查询方法说明（sqlc 生成）

本节说明 db/queries 中用于消息链路的关键方法，便于在服务中正确调用（通常放入同一 MySQL 事务中执行）。

### InsertMessageIndex

- 作用：在 MySQL 的 `message_index` 表写入一条消息索引（热数据）。
- 参数（按顺序）：
  - message_id, conversation_id, sender_id, recipient_id,
  - message_type, seq, reply_to_msg_id, status
- 何时调用：分配好会话内序列号（seq）后，写索引；消息体写入 MongoDB。
- 典型用法：与 `UpsertConversationOnSend`、`InsertOutboxEvent` 放入同一事务，确保“落库 + 事件”一致。

### UpsertConversationOnSend

- 作用：创建或更新会话元信息（单聊），维护 `last_message_id` 与 `last_seq`。
- 参数（按顺序）：
  - conversation_id, type 固定为 1（单聊，语句内置）, participants=JSON_ARRAY(userA,userB), last_message_id, last_seq
- 何时调用：发送消息时，确保会话存在；若已存在则更新最后一条消息与最新序列号。
- 幂等性：相同 `conversation_id` 多次调用不会重复创建，会更新元信息与 `updated_at`。

### IncrUnreadOnRecipient

- 作用：给接收方在 `user_conversation` 表中对应会话的 `unread_count` + 1。
- 参数（按顺序）：
  - user_id(=recipient_id), conversation_id
- 何时调用：写入 `message_index` 后，为对端累计未读数（发送者自己通常不累加）。
- 注意：需预先通过 `UpsertUserConversationOnSend` 为双方插入一条用户-会话记录（不存在则创建）。

### InsertOutboxEvent

- 作用：在 `outbox_events` 表追加一条待投递事件（状态 `pending`），用于 Outbox 模式的可靠投递。
- 配套方法：
  - `GetPendingOutboxEvents(limit)` 拉取待投递事件
  - `MarkOutboxEventSent(id)` 标记已发送
  - `MarkOutboxEventFailed(id)` 标记失败并回退 `next_delivery_at`

### 推荐事务顺序（伪代码）

```go
err := withTx(ctx, db, func(q *dao.Queries) error {
    // 1) 索引入库（MySQL 热数据）
    if err := q.InsertMessageIndex(ctx, dao.InsertMessageIndexParams{ /* 填充参数 */ }); err != nil { return err }

    // 2) 会话元信息（创建/更新最后消息与序列）
    if err := q.UpsertConversationOnSend(ctx, dao.UpsertConversationOnSendParams{ /* 填充参数 */ }); err != nil { return err }

    // 3) 确保双方 user_conversation 存在
    _ = q.UpsertUserConversationOnSend(ctx, senderID, convID)
    _ = q.UpsertUserConversationOnSend(ctx, recipientID, convID)

    // 4) 为接收方未读+1
    if err := q.IncrUnreadOnRecipient(ctx, dao.IncrUnreadOnRecipientParams{ /* recipientID, convID */ }); err != nil { return err }

    // 5) 写 Outbox 事件（pending）
    if err := q.InsertOutboxEvent(ctx, dao.InsertOutboxEventParams{ /* topic, payload */ }); err != nil { return err }

    return nil
})
// 6) 事务成功后并行：
//    - MongoDB 写消息体（若未在事务前已写）
//    - Outbox 派发器扫描并发布到 MQ
```

以上方法的配合，确保了消息索引、会话状态与可靠事件投递的一致性；消息体采用 MongoDB 存储，实现冷热数据分离与高效查询。

## 消息投递与 Kafka/Outbox

- 事务边界内：完成 Mongo 消息体持久化与 MySQL 索引更新，并写入 `outbox_events(topic='message.deliver', payload=消息元数据)`。
- 事务提交后：
  - Fast-path：直接发布 Kafka(`${topic_prefix}.message.deliver`)，失败忽略；
  - Outbox 派发器：按 `next_delivery_at` 扫描 `pending` 事件，发布成功则 `sent`，失败 `failed` 并回退下次时间，重试退避。

Payload 建议字段：

- message_id, conversation_id, seq, sender_id, recipient_id, type

配置：

- config.yaml 中 `broker.kafka_brokers: ["localhost:9092"]`，`broker.topic_prefix: "im"`。

## Connect 侧 Kafka 消费与投递

- Connect 订阅 `${topic_prefix}.message.deliver`，对 `recipient_id` 进行路由：
  - 找到在线设备连接（internal/connect/hub.go 的 ConnectManager）。
  - 封装为 `connectpb.Packet{Command=MESSAGE, Data=payload}`，二进制写入 WebSocket。
- 不在线：仅记录日志（后续由拉取/未读补齐）。

运行：

- `make build-all && make start-services`，确保 Kafka、MySQL、Redis、Mongo 已启动。
- 观察 `logs/connect.log`、`logs/outbox.log` 以确认消费与投递。

## 总结

通过分离不同的消息类型，我们获得了：

1. **性能优化**：客户端可以根据类型选择性渲染和加载
2. **存储优化**：不同类型可以使用不同的存储策略和索引
3. **业务清晰**：每种类型有明确的处理逻辑和校验规则
4. **可扩展性**：添加新的消息类型（如红包、名片等）非常容易
5. **监控友好**：可以方便地按类型进行监控和统计

这种设计虽然增加了一些复杂性，但为系统的性能、可维护性和可扩展性奠定了坚实的基础。
